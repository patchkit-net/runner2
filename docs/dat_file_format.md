# Launcher Data File Documentation

This documentation provides a comprehensive guide on how to read and interpret the `.dat` files generated by the `LauncherData` Ruby class from the `VersionProcessing` module. The `.dat` file can be saved in either **binary** or **JSON** format. This guide covers both formats, detailing their structures and the encoding mechanisms used.

---

## Table of Contents

1. [Overview](#overview)
2. [File Formats](#file-formats)
   - [Binary Format](#binary-format)
   - [JSON Format](#json-format)
3. [Encoding Mechanism](#encoding-mechanism)
4. [Decoding Process](#decoding-process)
   - [Decoding Binary Format](#decoding-binary-format)
   - [Decoding JSON Format](#decoding-json-format)
5. [Example Code](#example-code)
   - [Decoding Binary Format in Ruby](#decoding-binary-format-in-ruby)
   - [Decoding JSON Format in Ruby](#decoding-json-format-in-ruby)
6. [Error Handling](#error-handling)
7. [Appendix](#appendix)
   - [Magic Bytes](#magic-bytes)
   - [Helper Methods](#helper-methods)

---

## Overview

The `.dat` file generated by the `LauncherData` class encapsulates essential launcher configuration data, such as secrets and application metadata. Depending on the chosen format during saving, the file can be either in a compact binary form or a more readable JSON format, both employing a specific encoding scheme to ensure data integrity.

---

## File Formats

### Binary Format

When saved in binary format, the `.dat` file contains the `patcher_secret` and `app_secret`. Each string is encoded and preceded by its length.

**Structure:**

1. **patcher_secret**
   - **Length (4 bytes):** Little-endian unsigned integer representing the byte length of the encoded `patcher_secret`.
   - **Data:** Encoded byte array of `patcher_secret`.

2. **app_secret**
   - **Length (4 bytes):** Little-endian unsigned integer representing the byte length of the encoded `app_secret`.
   - **Data:** Encoded byte array of `app_secret`.

### JSON Format

When saved in JSON format, the `.dat` file starts with a set of **magic bytes** followed by the encoded JSON string containing all relevant launcher data.

**Structure:**

1. **Magic Bytes (4 bytes):** `[46, 98, 76, 97]` which correspond to the ASCII characters `.bLa`.

2. **JSON Data**
   - **Length (4 bytes):** Little-endian unsigned integer representing the byte length of the encoded JSON string.
   - **Data:** Encoded byte array of the JSON string containing:
     - `patcher_secret`
     - `app_secret`
     - `app_display_name`
     - `app_author`
     - `app_identifier`

---

## Encoding Mechanism

Both binary and JSON formats utilize a specific encoding scheme applied to strings before writing them to the file. The encoding process involves the following steps:

1. **Byte Interleaving:**
   - For each byte in the original string, a `0` byte is inserted immediately after it. This effectively doubles the byte array length.

2. **Byte Transformation:**
   - Each byte in the interleaved array undergoes the following operations:
     - **Bitwise NOT:** Invert all bits of the byte (`~b`).
     - **MSB Handling:**
       - Extract the Most Significant Bit (MSB) of the byte.
       - Shift the byte left by one bit.
       - Mask the byte to ensure it remains within `0-255`.
       - If the original MSB was `1`, set the Least Significant Bit (LSB) of the transformed byte to `1`; otherwise, set it to `0`.

This encoding ensures that the data is obfuscated, providing a basic layer of protection against straightforward data reading.

---

## Decoding Process

To read and interpret the `.dat` file, reverse the encoding process applied during saving. The decoding process varies slightly depending on whether the file is in binary or JSON format.

### Decoding Binary Format

**Steps:**

1. **Read `patcher_secret`:**
   - **Length:** Read the first 4 bytes as a little-endian unsigned integer to determine the length of the encoded `patcher_secret`.
   - **Data:** Read the next `length` bytes corresponding to the encoded `patcher_secret`.
   - **Decode:** Apply the decoding algorithm to retrieve the original `patcher_secret` string.

2. **Read `app_secret`:**
   - **Length:** Read the subsequent 4 bytes as a little-endian unsigned integer to determine the length of the encoded `app_secret`.
   - **Data:** Read the next `length` bytes corresponding to the encoded `app_secret`.
   - **Decode:** Apply the decoding algorithm to retrieve the original `app_secret` string.

**Decoded Data:**

- `patcher_secret`
- `app_secret`

### Decoding JSON Format

**Steps:**

1. **Verify Magic Bytes:**
   - Read the first 4 bytes and ensure they match `[46, 98, 76, 97]` (i.e., `.bLa`). If not, the file may not be in JSON format.

2. **Read JSON Data:**
   - **Length:** Read the next 4 bytes as a little-endian unsigned integer to determine the length of the encoded JSON string.
   - **Data:** Read the next `length` bytes corresponding to the encoded JSON string.
   - **Decode:** Apply the decoding algorithm to retrieve the original JSON string.
   - **Parse JSON:** Convert the JSON string into a data structure (e.g., a hash or dictionary) to access the following fields:
     - `patcher_secret`
     - `app_secret`
     - `app_display_name`
     - `app_author`
     - `app_identifier`

**Decoded Data:**

- `patcher_secret`
- `app_secret`
- `app_display_name`
- `app_author`
- `app_identifier`

---

## Example Code

Below are example implementations in Ruby for decoding both binary and JSON `.dat` files.

### Decoding Binary Format in Ruby

```ruby
require 'stringio'

module VersionProcessing
  class LauncherDataDecoder
    def self.decode_binary(filename)
      File.open(filename, 'rb') do |file|
        patcher_secret = read_encoded_string(file)
        app_secret = read_encoded_string(file)
        return {
          patcher_secret: patcher_secret,
          app_secret: app_secret
        }
      end
    end

    def self.read_encoded_string(file)
      length_bytes = file.read(4)
      length = length_bytes.unpack('V').first
      encoded_data = file.read(length)
      decode_byte_array(encoded_data.bytes)
    end

    def self.decode_byte_array(encoded_bytes)
      decoded_bytes = encoded_bytes.map do |b|
        # Reverse the encoding steps
        msb = b & 1
        b = (b >> 1) | (msb << 7)
        b = ~b & 0xFF
      end

      # Remove interleaved zero bytes
      original_bytes = decoded_bytes.each_slice(2).map(&:first)
      original_bytes.pack('C*').force_encoding('UTF-8')
    end
  end
end

# Usage
decoded_data = VersionProcessing::LauncherDataDecoder.decode_binary('path/to/launcher.dat')
puts decoded_data[:patcher_secret]
puts decoded_data[:app_secret]
```

### Decoding JSON Format in Ruby

```ruby
require 'json'

module VersionProcessing
  class LauncherDataDecoder
    MAGIC_BYTES = [46, 98, 76, 97].pack('C*') # ".bLa"

    def self.decode_json(filename)
      File.open(filename, 'rb') do |file|
        magic = file.read(4)
        unless magic == MAGIC_BYTES
          raise "Invalid magic bytes. Not a JSON format launcher.dat file."
        end

        json = read_encoded_string(file)
        JSON.parse(json, symbolize_names: true)
      end
    end

    def self.read_encoded_string(file)
      length_bytes = file.read(4)
      length = length_bytes.unpack('V').first
      encoded_data = file.read(length)
      decode_byte_array(encoded_data.bytes)
    end

    def self.decode_byte_array(encoded_bytes)
      decoded_bytes = encoded_bytes.map do |b|
        # Reverse the encoding steps
        msb = b & 1
        b = (b >> 1) | (msb << 7)
        b = ~b & 0xFF
      end

      # Remove interleaved zero bytes
      original_bytes = decoded_bytes.each_slice(2).map(&:first)
      original_bytes.pack('C*').force_encoding('UTF-8')
    end
  end
end

# Usage
decoded_json = VersionProcessing::LauncherDataDecoder.decode_json('path/to/launcher.dat')
puts decoded_json[:patcher_secret]
puts decoded_json[:app_secret]
puts decoded_json[:app_display_name]
puts decoded_json[:app_author]
puts decoded_json[:app_identifier]
```

---

## Error Handling

When decoding `.dat` files, consider the following potential errors and handle them appropriately:

- **Invalid Magic Bytes:** Ensure that the first four bytes match the expected magic bytes for JSON format. If not, and if JSON format is expected, raise an error.

- **Incomplete Data:** Verify that the file contains enough bytes as indicated by the length fields. Handle cases where the file might be truncated or corrupted.

- **Encoding Issues:** Ensure that the decoded byte arrays correctly translate to valid UTF-8 strings. Handle any encoding exceptions that may arise.

- **JSON Parsing Errors:** When decoding JSON format, handle any parsing errors due to malformed JSON strings.

---

## Appendix

### Magic Bytes

The JSON format `.dat` file starts with the following **magic bytes** to identify its format:

- **Bytes:** `[46, 98, 76, 97]`
- **ASCII Representation:** `.bLa`

This sequence helps in differentiating JSON format files from binary format files.

### Helper Methods

The encoding and decoding processes utilize several helper methods:

- **`write_string(file, str)`**
  - Encodes a string and writes its length followed by the encoded byte array to the file.

- **`str_to_encoded_byte_array(str)`**
  - Converts a string to an encoded byte array by interleaving zero bytes and applying bitwise transformations.

- **`decode_byte_array(encoded_bytes)`**
  - Reverses the encoding process to retrieve the original byte array from the encoded bytes.

Understanding these helper methods is crucial for implementing accurate decoding mechanisms.

---

## Summary

This documentation outlines the structure and encoding mechanisms of `.dat` files generated by the `LauncherData` Ruby class. By following the decoding processes for both binary and JSON formats, developers can accurately read and interpret the data contained within these files. Example code snippets in Ruby provide practical implementations to facilitate this process.

For further assistance or questions, please refer to the source code of the `LauncherData` class or contact the development team.